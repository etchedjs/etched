/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020-2021
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{iterator}=Symbol,{assign,create,freeze,fromEntries,getOwnPropertyDescriptors,getOwnPropertySymbols,keys}=Object,enumerable=!0,symbol=Symbol("@etchedjs/etched"),registry=new WeakMap,get=()=>{},set=e=>{},prototype=frozen(null,{constructor:{value:{[symbol]:()=>{}}[symbol]}});prototype.constructor.prototype=prototype,freeze(prototype.constructor);const{AggregateError=(()=>{function e(e,t){return assign(this,{errors:e,message:t})}return e.prototype=assign(new Error,{constructor:e,message:"",name:"AggregateError"}),e})()}=globalThis;export const etched=instance(init());export function etch(e,...t){return etches(e,e),aggregate(e,mix,t)}export function etches(e,t){if(!find(object(e)))throw new TypeError("Must be etched `model`");const r=find(object(t));return r&&(t===e||r.parents.includes(e))}export function fulfill(e,...t){return etches(e,e),aggregate(e,all,t)}export function fulfills(e,t){if(etches(e,t)){const{fulfilled:r}=find(t),{keys:n}=find(e);if(n.every((e=>r.includes(e))))return!0}}export function model(...e){return aggregate(etched,merge,e)}export function namespace({url:e},...t){return model({[Symbol("@etchedjs/namespace")]:e},...t)}export const iterable=model({*[Symbol.iterator](){for(const e of Object.entries(this))yield e}});function aggregate(e,t,[r={},...n]){return reduce(map([r,...n],normalize),t,e)}function all(e,t){const r=find(e),n=find(t),{fulfilled:s,setters:o}=r,i=init(r.keys,s,e,t),c=[];return forEach(r.keys,(t=>{const s=n.getters[t]||r.getters[t];if(o[t])try{const r=fill(e,o,t,s||get);s&&(i.getters[t]=r),i.fulfilled=push(i.fulfilled,t)}catch(e){c.push([t,e])}})),i.setters=o,validate(c),instance(i)}function both({getters:e,keys:t,setters:r}){return fromEntries(reduce(t,((t,n)=>[...t,...r[n]?[[n,{enumerable:true,set}]]:e[n]?[[n,{enumerable:true,value:e[n]()}]]:[]]),[]))}function chain(e,t){return reduce(find(t).parents,push,[...e,t])}function describe(e){const t=[...keys(e),...getOwnPropertySymbols(e)];return{descriptors:map(t,descriptor,getOwnPropertyDescriptors(e)),keys:t}}function descriptor(e){return[e,this[e]]}function fill(e,t,r,n){const s=n();return forEach(t[r],(t=>t.call(e,s))),n}function find(e){return registry.get(e)}function forEach(e,t){const{length:r}=e;for(let n=0;n<r;n+=1)t(e[n])}function frozen(e,t={}){return freeze(create(e,t))}function init(e=[],[...t]=[],...r){const n=reduce(r,chain,[]),[s]=n;return{keys:e,fulfilled:t,getters:assign(create(null),s?find(s).getters:{}),parents:n,setters:create(null)}}function instance(e){return register(frozen(frozen(prototype,both(e)),values(e)),e)}function map(e,t,r){const{length:n}=e,s=[];for(let o=0;o<n;o+=1)s.push(t.call(r,e[o]));return s}function merge(e,t){const r=find(e),n=find(t),s=reduce(n.keys,push,r.keys),{fulfilled:o,setters:i}=r,c=init(s,o,e,t),u=[];return forEach(n.keys,(t=>{const s=n.getters[t],o=n.setters[t];if(i[t]&&s)try{c.getters[t]=fill(e,i,t,s),c.fulfilled=push(c.fulfilled,t)}catch(e){u.push([t,e])}else if(r.getters[t]){if(s&&r.getters[t]!==s){const e=new ReferenceError(`Duplicate constant \`${"symbol"==typeof t?"symbol":t}\``);u.push([t,e])}}else i[t]&&o?c.setters[t]=reduce(o,push,i[t]):s?(c.getters[t]=s,c.fulfilled=push(c.fulfilled,t)):c.setters[t]=o})),forEach(keys(i),(e=>{c.getters[e]||c.setters[e]||(c.setters[e]=i[e])})),validate(u),instance(c)}function mix(e,t){const r=find(e),n=find(t),{fulfilled:s,setters:o}=r,i=init(r.keys,s,e,t),c=[];return forEach(n.keys,(t=>{const r=n.getters[t];if(o[t]&&r)try{i.getters[t]=fill(e,o,t,r),i.fulfilled=push(i.fulfilled,t)}catch(e){c.push([t,e])}})),i.setters=o,validate(c),instance(i)}function normalize(e){const t=object(e,!0);return find(t)?t:instance(parse(t))}function object(e,t=!1){if(null!==e&&"object"==typeof e)return e[iterator]&&e.entries?fromEntries(e.entries()):e;if(t)throw new TypeError("Must be an object")}function parse(e){const{descriptors:t,keys:r}=describe(e);return reduce(t,parser,[init(r,[],etched),e]).shift()}function parser([e,t],[r,{set:n}]){const{getters:s,setters:o}=e,i=t[r];return[{...e,...n?{setters:{...o,[r]:[n]}}:{getters:{...s,[r]:()=>i}}},t]}function push(e,t){return e.includes(t)?e:[...e,t]}function reduce(e,t,r){const{length:n}=e;let s=r;for(let r=0;r<n;r+=1)s=t(s,e[r],r);return s}function register(e,t){return registry.set(e,t),e}function validate(e){if(e.length)throw new AggregateError(e,"Unsafe etching")}function values({getters:e,keys:t}){return fromEntries(reduce(t,((t,r)=>e[r]?[...t,[r,{enumerable:true,value:e[r]()}]]:t),[]))}
