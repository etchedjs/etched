/**
 * @module etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 */
const{create:create,entries:entries,freeze:freeze,fromEntries:fromEntries,getOwnPropertyDescriptors:getOwnPropertyDescriptors,getPrototypeOf:getPrototypeOf,isPrototypeOf:isPrototypeOf}=Object,noop={set(){}};export const etched=frozen(frozen(null));export function etches(e,t){return is(prototype(e),t)};export function model(e=null,...t){const r=null===e?etched:e,n=prototype(r);if(!etches(etched,r))throw new ReferenceError("`instance` must be etched or `null`");const o=getOwnPropertyDescriptors(n);return etch(frozen(frozen(r,{...o,...t.reduce(declare,o)})))};export function etch(e,...t){const r=prototype(e);if(!is(etched,r))throw new ReferenceError("`instance` must be etched");const n=getOwnPropertyDescriptors(r),o=entries(n).filter(hasSetter);return frozen(r,t.map(merge,o).flat().reduce(set,n))};function hasSetter([,{set:e}]){return e}function merge(e){return this.map(extract,e)}function extract([e]){const{[e]:t}=this;return void 0===t?[]:[e,t]}function call(e){e(...this)}function is(e,t){return isPrototypeOf.call(e,t)}function setter(e,t){const r=[e.set,t.set];return{set:e=>r.forEach(call,[e])}}function value(e,t,r=!1){const{set:n}=t,{value:o}=e;return n(o),{enumerable:r,value:o}}function set(e,[t,r]){const{[t]:{set:n}}=e;return n(r),{...e,[t]:{enumerable:!0,value:r}}}function declare(e,t){return fromEntries(entries(getOwnPropertyDescriptors(t)).map(describe,e))}function describe([e,t]){const{[e]:r}=this;if(r&&!r.set)throw new ReferenceError("Unable to redeclare an etched constant");return[e,r?r.set&&t.set?setter(t,r):value(t,r):t.set?t:value(t,noop)]}function prototype(e){return e?getPrototypeOf(e):e}function frozen(e,t){return freeze(create(e,t))}
