/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020-2021
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{iterator}=Symbol,{assign,create,freeze,fromEntries,getOwnPropertyDescriptors,keys}=Object,enumerable=!0,symbol=Symbol("@etchedjs/etched"),registry=new WeakMap,set={[symbol]:e=>{}}[symbol],AggregateError=globalThis.AggregateError||(()=>{function e(r,t){return Error.captureStackTrace&&Error.captureStackTrace(this,e),assign(this,{errors:r,message:t})}return e.prototype=assign(new Error,{constructor:e,message:"",name:"AggregateError"}),e})();export const etched=instance(init());export function etch(e,...r){try{return etches(e,e),aggregate(e,mix,r)}catch(e){throw new(throwable(e))}}export function etches(e,r,t=null){if(!find(object(e)))throw new TypeError("Must be etched `model`");const n=find(object(r));if(n&&(r===e||n.parents.includes(e)))return!0;if("function"==typeof t)throw t();return!1}export function model(...e){try{return aggregate(etched,merge,e)}catch(e){throw new(throwable(e))}}function aggregate(e,r,[t={},...n]){return[t,...n].map(normalize).reduce(r,e)}function both({getters:e,keys:r,setters:t}){return fromEntries(r.reduce(((r,n)=>[...r,...t[n]?[[n,{enumerable:true,set}]]:e[n]?[[n,{enumerable:true,value:e[n]()}]]:[]]),[]))}function chain(e,r){return find(r).parents.reduce(push,[...e,r])}function describe(e){const r=keys(e);return{descriptors:r.map(descriptor,getOwnPropertyDescriptors(e)),keys:r}}function descriptor(e){return[e,this[e]]}function fill(e,r,t,n){const s=n();return r[t].forEach((r=>r.call(e,s))),n}function find(e){return registry.get(e)}function frozen(e,r={}){return freeze(create(e,r))}function init(e=[],...r){const t=r.reduce(chain,[]),[n]=t;return{keys:e,getters:n?{...find(n).getters}:{},parents:t,setters:{}}}function instance(e){const r=frozen(null,both(e));return register(frozen(r,values(e)),e)}function merge(e,r){const t=find(e),n=find(r),s=init(n.keys.reduce(push,t.keys),e,r),{setters:o}=t,c=[];return n.keys.forEach((r=>{const i=n.getters[r],u=n.setters[r];o[r]&&i?s.getters[r]=fill(e,o,r,i):t.getters[r]?t.getters[r]!==i&&c.push([r,new ReferenceError(`Duplicate constant \`${r}\``)]):o[r]&&u?s.setters[r]=u.reduce(push,o[r]):i?s.getters[r]=i:s.setters[r]=u})),keys(o).forEach((e=>{s.getters[e]||s.setters[e]||(s.setters[e]=o[e])})),validate(s,c)}function mix(e,r){const t=find(e),n=find(r),s=init(n.keys.reduce(push,t.keys),e,r),{setters:o}=t;return n.keys.forEach((r=>{const t=n.getters[r];o[r]&&t&&(s.getters[r]=fill(e,o,r,t))})),s.setters=o,validate(s,[])}function normalize(e){const r=object(e,!0);return find(r)?r:instance(parse(r))}function object(e,r=!1){if(null!==e&&"object"==typeof e)return e[iterator]&&e.entries?fromEntries(e.entries()):e;if(r)throw new TypeError("Must be an object")}function parse(e){const{descriptors:r,keys:t}=describe(e),n=init(t,etched);return r.reduce(parser,[n,e]).shift()}function parser([e,r],[t,{set:n}]){const{getters:s,setters:o}=e,c=r[t];return[{...e,...n?{setters:{...o,[t]:[n]}}:{getters:{...s,[t]:()=>c}}},r]}function push(e,r){return e.includes(r)?e:[...e,r]}function register(e,r){return registry.set(e,r),e}function throwable({constructor:e,errors:r,message:t}){return e===AggregateError?e.bind(null,r,t):e.bind(null,t)}function validate(e,r){if(r.length)throw new AggregateError(r,"Unsafe etching");return instance(e)}function values({getters:e}){return fromEntries(keys(e).map((r=>[r,{enumerable:true,value:e[r]()}])))}
