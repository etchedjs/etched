/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020-2021
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{iterator}=Symbol,{assign,create,freeze,fromEntries,getOwnPropertyDescriptors,getOwnPropertySymbols,keys}=Object,enumerable=!0,symbol=Symbol("@etchedjs/etched"),registry=new WeakMap,get=()=>{},set=e=>{},prototype=frozen(null,{constructor:{value:{[symbol]:()=>{}}[symbol]}});prototype.constructor.prototype=prototype,freeze(prototype.constructor);const{AggregateError}=globalThis;AggregateError&&!new AggregateError([])||(()=>{function e(t,r){return Error.captureStackTrace&&Error.captureStackTrace(this,e),assign(this,{errors:t,message:r})}e.prototype=assign(new Error,{constructor:e,message:"",name:"AggregateError"})})();export const etched=instance(init());export function etch(e,...t){try{return etches(e,e),aggregate(e,mix,t)}catch(e){throw new(capture(e))}}export function etches(e,t,r=null){if(!find(object(e)))throw new TypeError("Must be etched `model`");const n=find(object(t));return n&&(t===e||n.parents.includes(e))||thrower(r)}export function fulfill(e,...t){try{return etches(e,e),aggregate(e,required,t)}catch(e){throw new(capture(e))}}export function fulfills(e,t,r=null){try{if(etches(e,t)){const{getters:r}=find(t);if(find(e).keys.every((e=>r[e])))return!0}}catch(e){throw new(capture(e))}return thrower(r)}export function model(...e){try{return aggregate(etched,merge,e)}catch(e){throw new(capture(e))}}export function namespace({url:e},...t){try{return model({[Symbol("@etchedjs/etched:ns")]:e},...t)}catch(e){throw new(capture(e))}}function aggregate(e,t,[r={},...n]){return[r,...n].map(normalize).reduce(t,e)}function both({getters:e,keys:t,setters:r}){return fromEntries(t.reduce(((t,n)=>[...t,...r[n]?[[n,{enumerable:true,set}]]:e[n]?[[n,{enumerable:true,value:e[n]()}]]:[]]),[]))}function capture({constructor:e,errors:t,message:r}){return e===AggregateError?e.bind(null,t,r):e.bind(null,r)}function chain(e,t){return find(t).parents.reduce(push,[...e,t])}function describe(e){const t=[...keys(e),...getOwnPropertySymbols(e)];return{descriptors:t.map(descriptor,getOwnPropertyDescriptors(e)),keys:t}}function descriptor(e){return[e,this[e]]}function fill(e,t,r,n){const s=n();return t[r].forEach((t=>t.call(e,s))),n}function find(e){return registry.get(e)}function frozen(e,t={}){return freeze(create(e,t))}function init(e=[],...t){const r=t.reduce(chain,[]),[n]=r;return{keys:e,getters:assign(create(null),n?find(n).getters:{}),parents:r,setters:create(null)}}function instance(e){return register(frozen(frozen(prototype,both(e)),values(e)),e)}function merge(e,t){const r=find(e),n=find(t),s=init(n.keys.reduce(push,r.keys),e,t),{setters:o}=r,c=[];return n.keys.forEach((t=>{const i=n.getters[t],u=n.setters[t];if(o[t]&&i)try{s.getters[t]=fill(e,o,t,i)}catch(e){c.push([t,e])}else if(r.getters[t]){if(r.getters[t]!==i){const e=new ReferenceError(`Duplicate constant \`${t}\``);c.push([t,e])}}else o[t]&&u?s.setters[t]=u.reduce(push,o[t]):i?s.getters[t]=i:s.setters[t]=u})),keys(o).forEach((e=>{s.getters[e]||s.setters[e]||(s.setters[e]=o[e])})),validate(s,c)}function mix(e,t){const r=find(e),n=find(t),s=init(r.keys,e,t),{setters:o}=r,c=[];return n.keys.forEach((t=>{const r=n.getters[t];if(o[t]&&r)try{s.getters[t]=fill(e,o,t,r)}catch(e){c.push([t,e])}})),s.setters=o,validate(s,c)}function normalize(e){const t=object(e,!0);return find(t)?t:instance(parse(t))}function object(e,t=!1){if(null!==e&&"object"==typeof e)return e[iterator]&&e.entries?fromEntries(e.entries()):e;if(t)throw new TypeError("Must be an object")}function parse(e){const{descriptors:t,keys:r}=describe(e),n=init(r,etched);return t.reduce(parser,[n,e]).shift()}function parser([e,t],[r,{set:n}]){const{getters:s,setters:o}=e,c=t[r];return[{...e,...n?{setters:{...o,[r]:[n]}}:{getters:{...s,[r]:()=>c}}},t]}function push(e,t){return e.includes(t)?e:[...e,t]}function register(e,t){return registry.set(e,t),e}function required(e,t){const r=find(e),n=find(t),s=init(r.keys,e,t),{setters:o}=r,c=[];return r.keys.forEach((t=>{const r=n.getters[t]||get;if(o[t]&&r)try{s.getters[t]=fill(e,o,t,r)}catch(e){c.push([t,e])}})),s.setters=o,validate(s,c)}function thrower(e){if("function"==typeof e)throw e();return!1}function validate(e,t){if(t.length)throw new AggregateError(t,"Unsafe etching");return instance(e)}function values({getters:e,keys:t}){return fromEntries(t.reduce(((t,r)=>e[r]?[...t,[r,{enumerable:true,value:e[r]()}]]:t),[]))}
