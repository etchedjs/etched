/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{assign,create,freeze,getOwnPropertyDescriptors,getOwnPropertySymbols,keys}=Object,symbol=Symbol("@etchedjs/etched"),key=Array.prototype.includes.bind(["string","symbol"]);export const etched=context(null,freeze({prototypes:freeze([freeze([])]),rules:freeze([])}));export function etch(e,...t){const r=extract(e),{rules:n}=r,[s,o]=distinct(n.map(mix,[e,...t.map(object)]));return build(r,s,o)}export function etches(e,t){const r=extract(e),n=extract(t||{},!1),{prototypes:s=[]}=n;return n===r||s.some(inherits,r.prototypes)}export function model(...e){const t=freeze(uniques([etched,...e].map(parse))),r=t.flatMap(pairs).reduce(rule,[spread()]).shift(),n=freeze(uniques(entries(r).map(freeze))),[s,o]=distinct(n);return etch(build(freeze({prototypes:t,rules:n}),s,o),...e)}function pairs(e){const[t]=e;return key(typeof t)?[e]:e.flatMap(pairs)}function build(e,t,r){return frozen(context(t,e),r)}function context(e,t){return frozen(null,{...e,[symbol]:{value:t}})}function dedupe(e,t){return e.includes(t)?[]:[t]}function describe([e,{set:t,value:r,get:n=(()=>r)}]){return freeze([e,freeze({get:n,set:t})])}function distinct(e){return e.reduce(merge,[{},{}])}function entries(e){return[...keys(e),...getOwnPropertySymbols(e).filter(filter)].map(map,e)}function extract(e,t=!0){const{[symbol]:r}=e;if(t&&!r)throw new ReferenceError("An instance must be etched");return r||{}}function filter(e){return e!==symbol}function fill([e,t],r){const{[t]:n}=r;return[[...void 0===n?[]:[{get:()=>n}],...e],t]}function frozen(e=null,t={}){return freeze(create(e,t))}function inherits(e){return e===this||Array.isArray(e)&&e.some(inherits,this)}function item(e,t,r){return{...e,[r]:t}}function map(e){return[e,this[e]]}function merge([e,t],[r,n]){const{get:s,set:o}=n.reduce(reduce),u={enumerable:!0,...o?{set:o}:{value:s()}};return[{...e,[r]:u},o?t:{...t,[r]:u}]}function mix([e,t]){const[{set:r}]=t;return[e,r?this.reduce(fill,[t,e]).shift():t]}function object(e){return Array.isArray(e)?e.reduce(item,{}):e}function parse(e){return extract(e,!1).prototypes||freeze(entries(getOwnPropertyDescriptors(object(e))).map(describe))}function reduce(e,{get:t,set:r}){return e.get&&!e.set&&r&&r(e.get()),e.get?e:{get:t,set:r}}function rule([e,t={}],[r,{get:n,set:s}]){const{[r]:o=[]}=e,{[r]:u=[]}=t,[c]=o,i=[...dedupe(u,n),...dedupe(u,s)];if(c&&!c.set&&(s||n!==c.get))throw new ReferenceError(`Unable to redeclare an etched constant \`${r}\``);return[spread(e,{[r]:freeze([...i.length?[freeze({get:n,set:s})]:[],...o])}),spread(t,{[r]:[...u,...i]})]}function spread(e={},t={}){return assign(create(null),e,t)}function uniques(e){return[...new Set(e)]}
