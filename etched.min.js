/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 */
const{create,entries,freeze,fromEntries,getOwnPropertyDescriptors}=Object,symbol=Symbol("@etchedjs/etched");export const etched=context(null,freeze({prototypes:freeze([freeze([])]),rules:freeze([])}));export function etch(e,...t){const r=extract(e),{rules:n}=r,o=n.map(mix,[e,...t]).map(merge);return build(r,fromEntries(o))};export function etches(e,t){const r=extract(e),n=extract(t||{},!1);return n===r||n.prototypes.includes(r.prototypes[0])};export function model(...e){const t=freeze([etched,...e].map(parse).flat()),r=freeze(entries(t.flat().reduce(rule,[{}]).shift()).map(freeze));return build(freeze({prototypes:t,rules:r}),fromEntries(r.map(merge)))};function build(e,t){return frozen(context(etched,e),t)}function context(e,t){return frozen(e,{[symbol]:{value:t}})}function describe([e,{set:t,value:r,get:n=(()=>r)}]){return freeze([e,freeze({get:n,set:t})])}function extract(e,t=!0){const{[symbol]:r}=e;if(t&&!r)throw new ReferenceError("An instance must be etched");return r||{}}function fill([e,t],r){const{[t]:n}=r;return[[...void 0===n?[]:[{get:()=>n}],...e],t]}function frozen(e=null,t={}){return freeze(create(e,t))}function merge([e,t]){const{get:r,set:n}=t.reduce(reduce);return[e,{enumerable:!0,...n?{set:n}:{value:r()}}]}function mix([e,t]){const[{set:r}]=t;return[e,r?this.reduce(fill,[t,e]).shift():t]}function parse(e){return extract(e,!1).prototypes||[freeze(entries(getOwnPropertyDescriptors(e)).map(describe))]}function reduce(e,{get:t,set:r}){return e.get&&!e.set&&r&&r(e.get()),e.get?e:{get:t,set:r}}function rule([e,t={}],[r,{get:n,set:o}]){const{[r]:c=[]}=e,{[r]:s=[]}=t,[u]=c,f=[...dedupe(s,n),...dedupe(s,o)];if(u&&!u.set&&(o||n!==u.get))throw new ReferenceError("Unable to redeclare an etched constant");return[{...e,[r]:freeze([...f.length?[freeze({get:n,set:o})]:[],...c])},{...t,[r]:[...s,...f]}]}function dedupe(e,t){return e.includes(t)?[]:[t]}
