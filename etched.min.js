/**
 * @module etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 */
const{create:create,entries:entries,freeze:freeze,fromEntries:fromEntries,getOwnPropertyDescriptors:getOwnPropertyDescriptors,getPrototypeOf:getPrototypeOf,isPrototypeOf:isPrototypeOf}=Object,symbol=Symbol("@etchedjs/etched"),noop={set(){}},prototype=frozen(null,{[symbol]:{value:freeze([])}});export function etch(e,...t){if(!is(prototype,e))throw new ReferenceError("`instance` must be etched");const r=getPrototypeOf(e),o=getOwnPropertyDescriptors(r),n=entries(o).filter(settable),s=[e,...t].map(entry,n).flat().filter(Boolean);return frozen(r,{...fromEntries(s)})};export const etched=frozen(prototype);export function etches(e,t){return is(prototype,e)&&is(prototype,t)&&matches.call(e[symbol],t)};export function model(...e){const t=freeze(e.map(mixin)),r=t.map(getPrototypeOf).reduce(merge,{});return frozen(frozen(prototype,{...r,[symbol]:{value:t,enumerable:!0}}),r)};function describe(e,[t,{value:r,...o}]){const{[t]:{set:n}=noop}=e;let s={};if(o.set)s.enumerable=!0,s.set=n?e=>[o.set,n].forEach(call,[e]):o.set;else{if(!n)throw new ReferenceError("Unable to redeclare an etched constant");s.value=r}return{...e,[t]:s}}function call(e){e(...this)}function entry(e){return this.map(extract,e)}function extract([e,{set:t}]){const{[e]:r}=this;if(void 0!==r)return t(r),[e,{enumerable:!0,value:r}]}function frozen(e=null,t={}){return freeze(create(e,t))}function is(e,t){return isPrototypeOf.call(e,t)}function matches(e){const{[symbol]:t=[]}=e;return t===this||t.some(matches,this)}function merge(e,t){const{[symbol]:r,...o}=getOwnPropertyDescriptors(t);return entries(o).reduce(describe,e)}function mixin(e){return is(prototype,e)?e:frozen(frozen(prototype,{...getOwnPropertyDescriptors(e),[symbol]:{value:[]}}))}function settable([,{set:e}]){return e}
