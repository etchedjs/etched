/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{assign,create,entries,freeze,fromEntries,getOwnPropertyDescriptors}=Object,symbol=Symbol("@etchedjs/etched");export const etched=context(null,freeze({prototypes:freeze([freeze([])]),rules:freeze([])}));export function etch(e,...t){const r=extract(e),{rules:n}=r,o=n.map(mix,[e,...t.map(object)]).map(merge);return build(r,fromEntries(o))}export function etches(e,t){const r=extract(e),n=extract(t||{},!1),{prototypes:o=[]}=r;return n===r||o.includes(r.prototypes[0])}export function model(...e){const t=freeze([etched,...e].map(parse).flat()),r=freeze(entries(t.flat().reduce(rule,[spread()]).shift()).map(freeze));return etch(build(freeze({prototypes:t,rules:r}),fromEntries(r.map(merge))),...e)}function build(e,t){return frozen(context(etched,e),t)}function context(e,t){return frozen(e,{[symbol]:{value:t}})}function dedupe(e,t){return e.includes(t)?[]:[t]}function describe([e,{set:t,value:r,get:n=(()=>r)}]){return freeze([e,freeze({get:n,set:t})])}function extract(e,t=!0){const{[symbol]:r}=e;if(t&&!r)throw new ReferenceError("An instance must be etched");return r||{}}function fill([e,t],r){const{[t]:n}=r;return[[...void 0===n?[]:[{get:()=>n}],...e],t]}function frozen(e=null,t={}){return freeze(create(e,t))}function item(e,t,r){return{...e,[r]:t}}function merge([e,t]){const{get:r,set:n}=t.reduce(reduce);return[e,{enumerable:!0,...n?{set:n}:{value:r()}}]}function mix([e,t]){const[{set:r}]=t;return[e,r?this.reduce(fill,[t,e]).shift():t]}function object(e){return Array.isArray(e)?e.reduce(item,{}):e}function parse(e){return extract(e,!1).prototypes||[freeze(entries(getOwnPropertyDescriptors(object(e))).map(describe))]}function reduce(e,{get:t,set:r}){return e.get&&!e.set&&r&&r(e.get()),e.get?e:{get:t,set:r}}function rule([e,t={}],[r,{get:n,set:o}]){const{[r]:c=[]}=e,{[r]:s=[]}=t,[u]=c,i=[...dedupe(s,n),...dedupe(s,o)];if(u&&!u.set&&(o||n!==u.get))throw new ReferenceError("Unable to redeclare an etched constant");return[spread(e,{[r]:freeze([...i.length?[freeze({get:n,set:o})]:[],...c])}),spread(t,{[r]:[...s,...i]})]}function spread(e={},t={}){return assign(create(null),e,t)}
