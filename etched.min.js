/**
 * @module etchedjs/etched
 * @copyright Lcf.vs 2020
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 */
const{assign:assign,create:create,entries:entries,freeze:freeze,fromEntries:fromEntries,getOwnPropertyDescriptors:getOwnPropertyDescriptors,getPrototypeOf:getPrototypeOf,isPrototypeOf:isPrototypeOf}=Object,noop={set(){}};export const etched=frozen(frozen(null));export function etches(e,t){return is(prototype(e),t)};export function model(e=null,...t){const r=null===e?etched:e,n=prototype(r);if(!etches(etched,r))throw new ReferenceError("`instance` must be etched or `null`");const o=getOwnPropertyDescriptors(n);return etch(frozen(frozen(r,{...o,...t.reduce(declare,o)})))};export function etch(e,...t){const r=prototype(e);if(!is(etched,r))throw new ReferenceError("`instance` must be etched");const n=[e,...t].map(getOwnPropertyDescriptors);return frozen(r,fill(getOwnPropertyDescriptors(r),assign(...n)))};function call(e){e(...this)}function is(e,t){return isPrototypeOf.call(e,t)}function setter(e,t){const r=[e.set,t.set];return{set:e=>r.forEach(call,[e])}}function value(e,t,r=!1){const{set:n}=t,{value:o}=e;return n(o),{enumerable:r,value:o}}function set([e,t]){const{[e]:r}=this;return[e,r&&t.set&&!r.set?value(r,t,!0):t]}function fill(e,t){return fromEntries(entries(e).map(set,t))}function declare(e,t){return fromEntries(entries(getOwnPropertyDescriptors(t)).map(describe,e))}function describe([e,t]){const{[e]:r}=this;if(r&&!r.set)throw new ReferenceError("Unable to redeclare an etched constant");return[e,r?r.set&&t.set?setter(t,r):value(t,r):t.set?t:value(t,noop)]}function prototype(e){return e?getPrototypeOf(e):e}function frozen(e,t){return freeze(create(e,t))}
