/**
 * @module @etchedjs/etched
 * @copyright Lcf.vs 2020-2021
 * @licence MIT
 * @see {@link https://github.com/etchedjs/etched|Etched on GitHub}
 * @preserve
 */
const{iterator}=Symbol,{assign,create,freeze,fromEntries,getOwnPropertyDescriptors,getOwnPropertySymbols,keys}=Object,enumerable=!0,symbol=Symbol("@etchedjs/etched"),registry=new WeakMap,get=()=>{},set=e=>{},prototype=frozen(null,{constructor:{value:{[symbol]:()=>{}}[symbol]}});prototype.constructor.prototype=prototype,freeze(prototype.constructor);const{AggregateError}=globalThis;AggregateError&&!new AggregateError([])||(()=>{function e(t,r){return Error.captureStackTrace&&Error.captureStackTrace(this,e),assign(this,{errors:t,message:r})}e.prototype=assign(new Error,{constructor:e,message:"",name:"AggregateError"})})();export const etched=instance(init());export function etch(e,...t){try{return etches(e,e),aggregate(e,mix,t)}catch(e){throw new(capture(e))}}export function etches(e,t,r=null){if(!find(object(e)))throw new TypeError("Must be etched `model`");const n=find(object(t));return n&&(t===e||n.parents.includes(e))||thrower(r)}export function fulfill(e,...t){try{return etches(e,e),aggregate(e,all,t)}catch(e){throw new(capture(e))}}export function fulfills(e,t,r=null){try{if(etches(e,t)){const{fulfilled:r}=find(t),{keys:n}=find(e);if(n.every((e=>r.includes(e))))return!0}}catch(e){throw new(capture(e))}return thrower(r)}export function model(...e){try{return aggregate(etched,merge,e)}catch(e){throw new(capture(e))}}export function namespace({url:e},...t){return model({[Symbol("@etchedjs/namespace")]:e},...t)}function aggregate(e,t,[r={},...n]){return reduce(map([r,...n],normalize),t,e)}function all(e,t){const r=find(e),n=find(t),{fulfilled:s,setters:o}=r,c=init(r.keys,s,e,t),i=[];return forEach(r.keys,(t=>{const r=n.getters[t];if(o[t])try{const n=fill(e,o,t,r||get);r&&(c.getters[t]=n),c.fulfilled.push(t)}catch(e){i.push([t,e])}})),c.setters=o,validate(i),instance(c)}function both({getters:e,keys:t,setters:r}){return fromEntries(reduce(t,((t,n)=>[...t,...r[n]?[[n,{enumerable:true,set}]]:e[n]?[[n,{enumerable:true,value:e[n]()}]]:[]]),[]))}function capture({constructor:e,errors:t,message:r}){return e===AggregateError?e.bind(null,t,r):e.bind(null,r)}function chain(e,t){return reduce(find(t).parents,push,[...e,t])}function describe(e){const t=[...keys(e),...getOwnPropertySymbols(e)];return{descriptors:map(t,descriptor,getOwnPropertyDescriptors(e)),keys:t}}function descriptor(e){return[e,this[e]]}function fill(e,t,r,n){const s=n();return forEach(t[r],(t=>t.call(e,s))),n}function find(e){return registry.get(e)}function forEach(e,t){const{length:r}=e;for(let n=0;n<r;n+=1)t(e[n])}function frozen(e,t={}){return freeze(create(e,t))}function init(e=[],[...t]=[],...r){const n=reduce(r,chain,[]),[s]=n;return{keys:e,fulfilled:t,getters:assign(create(null),s?find(s).getters:{}),parents:n,setters:create(null)}}function instance(e){return register(frozen(frozen(prototype,both(e)),values(e)),e)}function map(e,t,r){const{length:n}=e,s=[];for(let o=0;o<n;o+=1)s.push(t.call(r,e[o]));return s}function merge(e,t){const r=find(e),n=find(t),s=reduce(n.keys,push,r.keys),{fulfilled:o,setters:c}=r,i=init(s,o,e,t),u=[];return forEach(n.keys,(t=>{const s=n.getters[t],o=n.setters[t];if(c[t]&&s)try{i.getters[t]=fill(e,c,t,s),i.fulfilled.push(t)}catch(e){u.push([t,e])}else if(r.getters[t]){if(s&&r.getters[t]!==s){const e=new ReferenceError(`Duplicate constant \`${"symbol"==typeof t?"symbol":t}\``);u.push([t,e])}}else c[t]&&o?i.setters[t]=reduce(o,push,c[t]):s?(i.getters[t]=s,i.fulfilled.push(t)):i.setters[t]=o})),forEach(keys(c),(e=>{i.getters[e]||i.setters[e]||(i.setters[e]=c[e])})),validate(u),instance(i)}function mix(e,t){const r=find(e),n=find(t),{fulfilled:s,setters:o}=r,c=init(r.keys,s,e,t),i=[];return forEach(n.keys,(t=>{const r=n.getters[t];if(o[t]&&r)try{c.getters[t]=fill(e,o,t,r),c.fulfilled.push(t)}catch(e){i.push([t,e])}})),c.setters=o,validate(i),instance(c)}function normalize(e){const t=object(e,!0);return find(t)?t:instance(parse(t))}function object(e,t=!1){if(null!==e&&"object"==typeof e)return e[iterator]&&e.entries?fromEntries(e.entries()):e;if(t)throw new TypeError("Must be an object")}function parse(e){const{descriptors:t,keys:r}=describe(e);return reduce(t,parser,[init(r,[],etched),e]).shift()}function parser([e,t],[r,{set:n}]){const{getters:s,setters:o}=e,c=t[r];return[{...e,...n?{setters:{...o,[r]:[n]}}:{getters:{...s,[r]:()=>c}}},t]}function push(e,t){return e.includes(t)?e:[...e,t]}function reduce(e,t,r){const{length:n}=e;let s=r;for(let r=0;r<n;r+=1)s=t(s,e[r],r);return s}function register(e,t){return registry.set(e,t),e}function thrower(e){if("function"==typeof e)throw e();return!1}function validate(e){if(e.length)throw new AggregateError(e,"Unsafe etching")}function values({getters:e,keys:t}){return fromEntries(reduce(t,((t,r)=>e[r]?[...t,[r,{enumerable:true,value:e[r]()}]]:t),[]))}
